-- 19.08.25 SQL Tag 2

-- Übungen zu LIKE, BETWEEN, IN

--1. Schreibe zwei verschiedene Abfragen, die alle Lieferungen vom 05.08 bzw. 06.08.1990 ausgeben
SELECT * FROM lieferung
WHERE ldatum IN('05.08.1990','06.08.1990');

-- oder
SELECT * FROM lieferung
WHERE ldatum BETWEEN '05.08.1990' AND '06.08.1990';


--2. Alle Lieferanten, deren Name mit A oder S beginnen
SELECT * FROM lieferant
WHERE lname LIKE 'A%' OR lname LIKE 'S%';

-- oder
SELECT * FROM lieferant
WHERE lname LIKE '[AS]%';

--3. Name und Status aller Lieferanten die in Hamburg oder Aachen leben
SELECT lname, status, lstadt FROM lieferant
WHERE lstadt IN('Hamburg','Aachen');

--4. Alle Lieferungen des Lieferanten L01, bei denen 200 oder 300 Stück Ware ausgeliefert wurden 
SELECT * FROM lieferung 
WHERE lnr = 'L01' AND lmenge IN(200,300);

------------------------------------------------------------------------------------------

-- Einsatz von Aggregatfunktionen

-- AVG		Durchschnitt von Spaltenwerten
-- MAX		größte Spaltenwert
-- MIN		kleinste Spaltenwert
-- SUM		Summe der Spaltenwerte
-- COUNT	Anzahl der Spaltenwerte

-- gesucht ist der kleinste status aller Lieferanten
SELECT MIN(status) FROM lieferant;

-- gesucht ist der nach der alphabetischen Reihenfolge erste Lieferant
SELECT MIN(lname) FROM lieferant;

-- Anzahl aller bisherigen lieferungen, die lieferanten ausgeführt haben
SELECT COUNT(*) FROM lieferung;

-- größte, kleinste und den durchschnitts status aller lieferanten
SELECT MAX(status) AS 'Maximum', MIN(status) AS 'Minimum', 
		AVG(Status) AS 'Durchschnitt' FROM lieferant;

-- Aggregatfunktionen dürfen nicht verschachtelt werden

-- geht nicht!
SELECT COUNT(MAX(status)) FROM lieferant;



-- größte liefermenge aller lieferungen
SELECT MAX(lmenge) FROM lieferung;

-- die Durchschnittsmenge aller gelagerten artikel
SELECT AVG(amenge) FROM artikel;


-- GROUP BY Klausel

-- legt Spalten fest, über die Gruppen gebildet werden
-- gruppiert Zeilen mit gleichen Werten damit man Aggregatfunktionen in ihnen nutzen kann

-- die kleinste liefermenge, jedes Lieferanten
SELECT lnr, MIN(lmenge) AS 'Mindestliefermenge' FROM lieferung
GROUP BY lnr;

-- Anzahl der Lieferanten pro Ort
SELECT lstadt, COUNT(lnr) FROM lieferant
GROUP BY lstadt;

-- kleinster status aller lieferanten pro Ort
SELECT lstadt , MIN(status) FROM lieferant
GROUP BY lstadt;

-- anzahl lieferungen pro lieferant
SELECT lnr, COUNT(lnr) FROM lieferung
GROUP BY lnr;

-- Summe aller gelagerten Artikel pro Farbe
SELECT farbe, SUM(amenge) FROM artikel
GROUP BY farbe;

-- die größte liefermenge des Artikels A02 pro lieferant
SELECT lnr, MAX(lmenge) FROM lieferung
WHERE anr = 'A02'
GROUP BY lnr;


----------------------------------------------------------------------------------------
-- HAVING-Klausel

-- HAVING ist die WHERE Abfrage für Gruppen
-- HAVING selektiert Gruppen die mit GROUP BY festgelegt wurden

-- In der GROUP BY klausel dürfen keine Aggregatfunktionen stehen in der HAVING schon

-- gesucht ist der größte Lieferantenstatus des jeweiligen Ortes von 
-- Lieferanten die nicht aus Aachen kommen. Wenn der durchschnittliche Statuswert nicht
-- kleiner als 15 ist.

SELECT MAX(status), lstadt FROM lieferant
WHERE lstadt != 'Aachen' AND AVG(status) > 15
GROUP BY lstadt;
-- geht nicht, da in einer WHERE Abfrage keine Aggregatfunktion vorkommen darf

-- besser wäre
SELECT MAX(status), lstadt FROM lieferant
WHERE lstadt != 'Aachen'
GROUP BY lstadt
HAVING AVG(status) > 15;


-- es gibt keine Einschränkung für die Anzahl der Aggregatfunktionen innherhalb einer 
-- HAVING-Klausel

SELECT lnr, SUM(lmenge) FROM lieferung
GROUP BY lnr
HAVING MIN(lmenge) < 300 AND AVG(lmenge) < 1300;


-------------------------------------------------------------------------------------------

-- Tabellen verbinden über Unterabfragen

-- ist eine Abfrage innerhalb einer Abfrage. Die erste Abfrage wird äußere und die anderen
-- innere Abfrage genannt. 

-- Es werden immer zuerst die inneren und anschließend die äußere Abfrage bearbeitet

-- gesucht sind alle Lieferanten, in der selben stadt leben 
-- in der der Artikel A02 gelagert wird

-- die tabellen lieferant und artikel werden benötigt

SELECT * FROM lieferant
WHERE lstadt = (SELECT astadt FROM artikel
				WHERE anr= 'A02');


-- gesucht sind die Lieferanten, deren status größer als der durchschnittsstatus
-- aller Lieferanten ist

SELECT * FROM lieferant
WHERE status > (SELECT AVG(status) FROM lieferant);

-- gesucht sind die Daten aller lieferanten, die schon einmal geliefert haben
SELECT * FROM lieferant
WHERE lnr IN (SELECT lnr FROM lieferung);

-- Artikelnummer und namen sowie der Lagerort aller Artikel die am 23.07.1990
-- ausgeliefert wurden

SELECT anr, aname, astadt FROM artikel
WHERE anr IN (SELECT anr FROM lieferung
				WHERE ldatum= '23.07.1990');

-- liefermenge und das lieferdatum an dem rote Muttern versendet wurden

SELECT lmenge, ldatum FROM lieferung
WHERE anr IN (SELECT anr FROM artikel
				WHERE farbe = 'rot' AND aname= 'Mutter');


-- Die Daten aller Lieferungen von Hamburger Lieferanten
SELECT * FROM lieferung
WHERE lnr IN (SELECT lnr FROM lieferant
				WHERE lstadt= 'Hamburg');


-- Nummern und Namen der Lieferanten, deren Status kleiner als der von L03 sind
SELECT lnr, lname FROM lieferant
WHERE status < (SELECT status FROM lieferant
				WHERE lnr= 'L03');

-- gewicht und der name aller artikel die von Lieferant L02 geliefert wurden
SELECT gewicht, aname FROM artikel
WHERE anr IN (SELECT anr FROM lieferung
				WHERE lnr = 'L02');

-- Nummern und Namen der Lieferanten, die den Artikel A05 nicht lieferten
SELECT lnr, lname FROM lieferant
WHERE lnr NOT IN (SELECT lnr FROM lieferung
					WHERE anr = 'A05');

-- die Daten aller lieferungen von Lieferanten mit dem status 20
SELECT * FROM lieferung
WHERE lnr IN (SELECT lnr FROM lieferant
				WHERE status = 20);

-------------------------------------------------------------------------------------------

-- Übungsaufgaben

/*
1. Gesucht ist die Menge aller grünen Artikel, minus die 200 
	die wir bereits verplant aber noch nicht versendet haben.
2. Gesucht sind alle Lieferanten mit dem höchsten Status.
3. Gesucht ist das durchschnittliche Gewicht aller Artikel.
4. Gesucht ist die größte Lieferung jedes Lieferanten,
	die nach dem 23.7.90 stattgefunden hat und deren durchschnittliche
	Liefermenge mindestens 250 beträgt.
5. Gesucht ist der kleinste Status des jeweiligen Wohnortes von 
	Lieferanten die nicht aus Erfurt kommen, wenn der durchschnittliche
	Statuswert am jeweiligen Ort nicht kleiner ist als 12
*/

-- 1.
SELECT aname, amenge - 200 FROM artikel
WHERE farbe = 'grün';

-- 2.
SELECT * FROM lieferant
WHERE status IN (SELECT MAX(status) FROM lieferant);

-- 3.
SELECT AVG(gewicht) AS 'Durchschnittsgewicht' FROM artikel;

--4. 
SELECT lnr, MAX(lmenge), ldatum FROM lieferung
WHERE ldatum > '23.07.1990'
GROUP BY lnr, ldatum
HAVING AVG(lmenge) >= 250;

--5.
SELECT lstadt, MIN(status) FROM lieferant
WHERE lstadt != 'Erfurt'
GROUP BY lstadt
HAVING AVG(status) >= 12;


-- mehr Übungsaufgaben

/*
6. Gesucht ist der Name, Nummer von allen Artikeln.
	Zudem soll die Menge der Artikel bewertet werden. Bis 600 Artikel
	soll nachbestellt werden, bis 1000 soll es unbedingt verkauft 
	werden, bis 1200 sollen sie verschenkt werden. Alle Artikel mit
	einem Bestand über 1200 sollen weggeworfen werden.
7. Schreibe eine Abfrage die das aktuelle Datum ausgibt.
8. Gesucht sind die Namen aller Lieferanten aus Aachen mit einem
	Statuswert zwischen 20 und 30
9. Gesucht sind die Namen und Nummern aller Artikel, deren Gewicht
	12, 14 oder 17 gramm beträgt.
10. Gesucht ist der Statuswert aller Lieferanten, die am 5.8.90 oder 
	6.8.90 ausgeliefert haben.
*/

-- Zusatz 11.: Namen und nummern aller artikel, die am selben ort wie A03 gelagert werden

--6.
SELECT anr, aname, amenge, CASE 
				WHEN amenge <= 600 THEN 'nachbestellen'
				WHEN amenge BETWEEN 601 AND 1000 THEN 'verkaufen'
				WHEN amenge BETWEEN 1001 AND 1200 THEN 'verschenken'
				ELSE 'wegwerfen'
				END AS 'Bewertung'
FROM artikel
ORDER BY amenge;

--7.
SELECT GETDATE() AS 'Datum';

--8.
SELECT lname, status FROM lieferant
WHERE lstadt= 'Aachen' 
GROUP BY lname, status
HAVING MIN(status) >= 20 AND MAX(status) <= 30;

-- oder
SELECT lname, status FROM lieferant
WHERE lstadt= 'Aachen' AND status BETWEEN 20 AND 30;

--9.
SELECT aname, anr FROM artikel
WHERE gewicht IN(12,14,17);

-- oder
SELECT aname, anr FROM artikel
WHERE gewicht = 12 OR gewicht = 14 OR gewicht= 17;

--10.
SELECT lnr, status FROM lieferant
WHERE lnr IN (SELECT lnr FROM lieferung 
				WHERE ldatum IN ('05.08.1990','06.08.1990'));

-- oder
SELECT lnr, status FROM lieferant
WHERE lnr IN (SELECT lnr FROM lieferung 
				WHERE ldatum BETWEEN '05.08.1990' AND '06.08.1990');

-- oder
SELECT lnr, status FROM lieferant
WHERE lnr IN (SELECT lnr FROM lieferung 
				WHERE ldatum ='05.08.1990' OR ldatum='06.08.1990');

-- 11. 
SELECT aname, anr FROM artikel
WHERE astadt IN (SELECT astadt FROM artikel
					WHERE anr='A03');